

#' Generate a PCA plot
#' @param pca_object Object generated by the rda() function from the vegan package
#' @param metadata.df Dataframe containing metadata and (optional) colours/shapes for variables
make_pca_ggplot <- function(
    # PCA object generated by the rda() function from vegan package.
  # Limited functionality for other ordination objects, e.g. CCA
  pca_object,
  metadata.df, # Dataframe containing metadata and (optional) colours/shapes for variables

  # Type of scaling to use for ordination, e.g.:
  # scaling = "none" means scaling = 0
  # scaling = "sites" means scaling = 1
  # scaling = "species" means scaling = 2
  # scaling = "symmetric" means scaling = 3
  scaling_choice = "symmetric",

  site_column = NULL, # Column in metadata listing the sites (samples). If not specified, assumes sites are rownames.

  label_sites = F, # Label the individual sites/samples
  site_label_variable = NULL,
  site_label_size = 3,
  site_label_colour = "black",
  site_label_font_type = "plain", # plain, bold, italic, bold.italic

  label_species = F, # Label the individual species/OTUs

  # variable_to_plot = NULL, # Variable to group/plot by
  fill_variable = NULL, # Variable to fill by
  colour_variable = NULL, # Variable to colour by
  shape_variable = NULL, # Variable to fill by

  discrete_variables = NULL, # Variable that can be used for grouping (colouring/shapes), envfit centroids
  continuous_variables = NULL, # Can be used for envfit vectors
  discrete_palette = NULL,
  continuous_palette = NULL,

  point_alpha = 1, # Transparency of points, 0 = invisible, 1= fully, visible, 0.5 = 50% transparent
  point_size = 0.8, # Size of points
  point_line_thickness = 1, # Thickness of point outline
  use_shapes = T,
  default_shape_type = "filled", # Whether to use filled shapes or hollow shapes

  plot_hulls = F, # Plot hulls
  hull_variable = NULL,
  hull_fill_alpha = 1, # The transparency of the hull fill
  hull_outline_alpha = 1, # The transparency of the hull outline
  label_hulls = F,
  hull_label_colour = "black",
  hull_label_size = 0.5,
  hull_label_font_type = 1,
  hull_border_width = .1,

  plot_ellipses = F, # Plot ellipse
  ellipse_variable = NULL,
  label_ellipse = F, # Label ellipse
  ellipse_label_size = 0.5, # Size of ellipse label
  ellipse_label_colour = "black",
  ellipse_label_font_type = 1,
  ellipse_border_width = 1, # Width of ellipse border
  ellipse_alpha = 1, # The transparency of the ellipses

  plot_spiders = F, # Plot spiders
  spider_variable = NULL,
  label_spider = F, # Label the spider centroid
  spider_label_size = 0.5, # Size of spider label
  spider_label_colour = "black",
  spider_label_font_type = 1,
  spider_alpha = 1, # The transparency of the spiders
  spider_line_width = 1, # Width of spider lines

  envfit_pvalue_threshold = 0.05,
  plot_envfit_discrete = F,
  envfit_discrete_scalar = 1,
  envfit_discrete_label_size = 0.5,
  envfit_discrete_label_colour = "black",
  envfit_discrete_label_font_type = 1,
  envfit_discrete_label_alpha = 1,
  envfit_discrete_label_type = "text",
  envfit_discrete_label_fill_colour = "white",

  plot_envfit_arrows = F,
  envfit_arrow_colour = "black",
  envfit_arrow_alpha = 1,
  envfit_arrow_thickness = 0.5,
  envfit_arrow_linetype = 1,
  envfit_arrow_scalar = 1,
  envfit_arrow_head_size = 0.3,
  envfit_arrow_label_scalar = 1,
  envfit_arrow_label_size = 0.5,
  envfit_arrow_label_colour = "black",
  envfit_arrow_label_font_type = 1,
  envfit_arrow_label_alpha = 1,
  envfit_arrow_label_type = "text",
  envfit_arrow_label_fill_colour = "white",

  plot_biplot = F,
  biplot_label_type = "text", # Currently uses envfit plotting paramters
  biplot_variables_to_plot.v = NULL, # "all" or vector of values

  plot_specie_arrows = F,
  label_specie_arrows = T, # Label the arrows
  num_top_species = 5, # How many 'species' to show with the largest contributions to the variance
  top_species_by_score = T, # Show top species based on score
  top_species_by_contribution = F, # Show top species based on % contribution

  species_to_include.v = NULL, # 'species' to include in plotting, in addition to top species
  specie_arrow_colour = "black", # Color of arrows
  specie_arrow_head_size = 0.3, # Size of arrow head
  specie_arrow_alpha = 1, # Transparency of arrows, 0 = invisible, 1= fully, visible, 0.5 = 50% transparent
  specie_arrow_thickness = .2, # Thickness of arrow
  specie_arrow_linetype = 1,
  specie_labeller_function = NULL, # Function to re-label the species/OTUs,
  specie_arrow_label_size = .5, # Size of arrow label
  specie_arrow_scalar = 1, # Scale of the arrows
  specie_arrow_label_colour = "black", # Colour of arrow label
  specie_arrow_label_font_type = 1, # Font type of arrow label : 1 Normal, 2 bold, 3 italic, 4 bold italic
  # specie_arrow_label_offset = 0, # How much to offset the arrow label
  specie_arrow_label_alpha = 1, # The transparency of the arrow labels
  specie_arrow_label_type = "text",
  specie_arrow_label_fill_colour = "white",

  plot_specie_points = F,
  species_point_colour = "red",
  species_point_fill_colour = "red",
  species_point_shape = 3,
  species_point_size = .1,
  species_point_alpha = 1,
  species_point_line_thickness = .1,
  highlight_origin = T, # Highlight the origin line

  component_choices = c(1,2)
){
  if(!require("pacman")){
    install.packages("pacman")
  }
  pacman::p_load("tidyverse", "vegan", "ggnewscale", "colorspace", "ggplot2")
  # ------------------------------------------------------------------
  # ------------------------------------------------------------------
  # Utility functions

  # Function to convert a dataframe to a matrix. First column becomes row names
  df2m <- function(mydataframe){
    mymatrix <- mydataframe
    rownames(mymatrix) <- mydataframe[,1]
    mymatrix[,1] <- NULL
    mymatrix <- as.matrix(mymatrix)
    mymatrix
  }

  # Function to convert a matrix to a dataframe. Rows become first column.
  # Specify 'column_name' to set the name of the new column (defaults to "Row_variable")
  m2df <- function(mymatrix, column_name = "Row_variable"){
    mydf <- as.data.frame(mymatrix)
    cur_names <- names(mydf)
    mydf[, column_name] <- rownames(mydf)
    rownames(mydf) <- NULL
    mydf <- mydf[,c(column_name,cur_names)]
    return(mydf)
  }

  colorRamp2 = function(breaks, colors, transparency = 0, space = "LAB") {
    # Taken from https://github.com/jokergoo/circlize/

    if(length(breaks) != length(colors)) {
      rlang::abort("Length of `breaks` should be equal to `colors`.\n")
    }

    colors = colors[order(breaks)]
    breaks = sort(breaks)

    l = duplicated(breaks)
    breaks = breaks[!l]
    colors = colors[!l]

    if(length(breaks) == 1) {
      rlang::abort("You should have at least two distinct break values.")
    }


    if(! space %in% c("RGB", "HSV", "HLS", "LAB", "XYZ", "sRGB", "LUV")) {
      rlang::abort("`space` should be in 'RGB', 'HSV', 'HLS', 'LAB', 'XYZ', 'sRGB', 'LUV'")
    }

    colors = t(col2rgb(colors)/255)

    attr = list(breaks = breaks, colors = colors, transparency = transparency, space = space)

    if(space == "LUV") {
      i = which(apply(colors, 1, function(x) all(x == 0)))
      colors[i, ] = 1e-5
    }

    transparency = 1-ifelse(transparency > 1, 1, ifelse(transparency < 0, 0, transparency))[1]
    transparency_str = sprintf("%X", round(transparency*255))
    if(nchar(transparency_str) == 1) transparency_str = paste0("0", transparency_str)

    fun = function(x = NULL, return_rgb = FALSE, max_value = 1) {
      if(is.null(x)) {
        rlang::abort("Please specify `x`\n")
      }

      att = attributes(x)
      if(is.data.frame(x)) x = as.matrix(x)

      l_na = is.na(x)
      if(all(l_na)) {
        return(rep(NA, length(l_na)))
      }

      x2 = x[!l_na]

      x2 = ifelse(x2 < breaks[1], breaks[1],
                  ifelse(x2 > breaks[length(breaks)], breaks[length(breaks)],
                         x2
                  ))
      ibin = .bincode(x2, breaks, right = TRUE, include.lowest = TRUE)
      res_col = character(length(x2))
      for(i in unique(ibin)) {
        l = ibin == i
        res_col[l] = .get_color(x2[l], breaks[i], breaks[i+1], colors[i, ], colors[i+1, ], space = space)
      }
      res_col = paste(res_col, transparency_str[1], sep = "")

      if(return_rgb) {
        res_col = t(col2rgb(as.vector(res_col), alpha = TRUE)/255)
        return(res_col)
      } else {
        res_col2 = character(length(x))
        res_col2[l_na] = NA
        res_col2[!l_na] = res_col

        attributes(res_col2) = att
        return(res_col2)
      }
    }

    attributes(fun) = attr
    return(fun)
  }

  # x: vector
  # break1 single value
  # break2 single value
  # rgb1 vector with 3 elements
  # rgb2 vector with 3 elements
  .get_color = function(x, break1, break2, col1, col2, space) {

    col1 = colorspace::coords(as(colorspace::sRGB(col1[1], col1[2], col1[3]), space))
    col2 = colorspace::coords(as(colorspace::sRGB(col2[1], col2[2], col2[3]), space))

    res_col = matrix(ncol = 3, nrow = length(x))
    for(j in 1:3) {
      xx = (x - break2)*(col2[j] - col1[j]) / (break2 - break1) + col2[j]
      res_col[, j] = xx
    }

    res_col = get(space)(res_col)
    res_col = colorspace::coords(as(res_col, "sRGB"))
    res_col[, 1] = .restrict_in(res_col[,1], 0, 1)
    res_col[, 2] = .restrict_in(res_col[,2], 0, 1)
    res_col[, 3] = .restrict_in(res_col[,3], 0, 1)
    hex(sRGB(res_col))
  }

  .restrict_in = function(x, lower, upper) {
    x[x > upper] = upper
    x[x < lower] = lower
    x
  }

  darken <- function(color, factor=1.4){
    col <- col2rgb(color)
    col <- col/factor
    col <- rgb(t(col), maxColorValue=255)
    col
  }

  lighten <- function(color, factor=1.4){
    col <- col2rgb(color)
    col <- col*factor
    col <- rgb(t(col), maxColorValue=255)
    col
  }
  # ------------------------------------------------------------------
  # ------------------------------------------------------------------

  pca.scores <- try(scores(pca_object, choices=c(1,2,3)))
  if(inherits(pca.scores, "try-error")) {
    return()
  }

  # Get component/coordinate x,y coordinates
  pca_site_scores <- vegan::scores(pca_object, display = "sites", choices = component_choices, scaling = scaling_choice)
  pca_specie_scores <- vegan::scores(pca_object, display = "species", choices = component_choices,scaling = scaling_choice)

  # Check if biplot information is in the ordination object.
  # Extract coordinates and rownames (variables) for plotting
  ordination_scores <- vegan::scores(pca_object)
  biplot.df <- NULL
  if ("biplot" %in% names(ordination_scores)){
    biplot.df <- m2df(ordination_scores$biplot, "Variable")
    rownames(biplot.df) <- biplot.df$Variable
    if (!is.null(biplot_variables_to_plot.v)){
      if (all(biplot_variables_to_plot.v %in% rownames(biplot.df))){
        biplot.df <- biplot.df[biplot_variables_to_plot.v,]
      } else{
        warning("Some defined biplot variables are not in the biplot data. Plotting all available.")
      }
    }
    colnames(biplot.df)[2] <- "Biplot1"
    colnames(biplot.df)[3] <- "Biplot2"
  }

  # pca_specie_scores <- try(vegan::scores(pca_object, display = "species", choices = component_choices,scaling = scaling_choice))
  if(length(pca_specie_scores) == 0) {
    print("No species scores available")
    pca_specie_scores <- NULL
  } #else{
  #pca_specie_scores_available <- T
  #}
  # ------------------------------------------------------------------
  # If site column specified and in metadata, make rownames the site column
  if (all(!is.null(site_column) && site_column %in% colnames(metadata.df))){
    rownames(metadata.df) <- as.character(metadata.df[,site_column])
  }
  # Check all entries in the PCA object are also in the metadata
  if (!all(rownames(pca_site_scores) %in% rownames(metadata.df))){
    error_message <- paste0("There are rows in the PCA object that are not defined in the metadata.
                             Rownames in the metadata need to match those used in the PCA object,
                             or a 'site_column' in the metadata needs to be specified and match.")
    stop(error_message)
  }
  if ("_site_name" %in% colnames(metadata.df)){
    error_message <- paste0("Found a column named '_site_name' in your metadata. This column name is
                            required in this function. Please remove/rename.")
    stop(error_message)
  }
  # Also make a column for the rownames (used later)
  metadata.df$`_site_name` <- rownames(metadata.df)

  # Ensure metadata and pca_site_scores are the same order
  # First filter to only those metadata entries in the PCA object
  if (!all(metadata.df$`_site_name` %in% rownames(pca_site_scores))){
    metadata.df <- metadata.df[metadata.df$`_site_name` %in% rownames(pca_site_scores),]
  }
  metadata.df <- metadata.df[order(metadata.df$`_site_name`),]
  pca_site_scores <- pca_site_scores[metadata.df$`_site_name`,]

  # Check all specified variables are provided in the metadata
  for (myvar in unique(c(discrete_variables, continuous_variables))){
    if (! myvar %in% colnames(metadata.df)){
      error_message <- paste0("Variable ", myvar, " was not found in the provided metadata.")
      stop(error_message)
    }
  }
  if (!all(c(fill_variable, colour_variable, shape_variable, hull_variable, ellipse_variable, spider_variable) %in% c(discrete_variables, continuous_variables))){
    error_message <- paste0("One of the provided fill_variable, colour_variable or shape_variable
                            was not specified in discrete_variables or continuous_variables")
    stop(error_message)
  }

  # Only use variables where there is data
  # Also refer to these vectors for other sections.
  # TODO - might be simpler to check for empty variables, warn and exit
  envfit_continuous_variables.v <- metadata.df[,unique(c(continuous_variables)), drop =F] %>% sapply(., function(x)all(is.na(x)))
  envfit_continuous_variables.v <- names(envfit_continuous_variables.v[envfit_continuous_variables.v == F])

  envfit_discrete_variables.v <- metadata.df[,unique(c(discrete_variables)), drop =F] %>% sapply(., function(x)all(is.na(x)))
  envfit_discrete_variables.v <- names(envfit_discrete_variables.v[envfit_discrete_variables.v == F])

  # ------------------------------------------------------------------
  # Create colours for each variable
  if (is.null(discrete_palette)) {
    # discrete_annotation_palette <- colour_palette_206
    discrete_palette <- c("#8eec45","#0265e8","#f6a800","#bf6549","#486900","#c655a0","#00d1b6","#ff4431","#aeb85c","#7e7fc8")
  }
  if (is.null(continuous_palette)){
    continuous_palette <- colorRampPalette(c("#17468a","#ffdd47","#99113a"))
  } else{
    continuous_palette <- colorRampPalette(continuous_palette)
  }
  colour_lists <- list()
  for (myvar in unique(c(discrete_variables, continuous_variables))){
    var_colour_name <- paste0(myvar, "_colour")
    if (!is.null(envfit_continuous_variables.v) & myvar %in% envfit_continuous_variables.v){
      # If continuous variable
      # TODO check for existing continuous colour? Could not create a col_fun.
      # Might be simpler to treat as discrete and then define legend
      variable_values.v <- unique(metadata.df[,myvar])
      variable_breaks <- seq(min(variable_values.v, na.rm = T), max(variable_values.v,na.rm = T), length.out = 10)
      # FIXME if only one value for continuous, this breaks. This if check is a temporary fix
      if (length(unique(variable_breaks)) == 1) {
        warning(paste0("Cannot assign colours to variable: ", myvar, " as there is only one unique value"))
        next
      } else{
        col_fun <- colorRamp2(breaks = variable_breaks,
                              colors = continuous_palette(length(variable_breaks)))
      }

      # Error: You should have at least two distinct break values.
      colour_lists[[myvar]] <- list("colour_function" = col_fun, "colour_breaks" = variable_breaks)
    } else if (!is.null(envfit_discrete_variables.v) & myvar %in% envfit_discrete_variables.v){
      # If discrete variable
      myvar_values <- factor(unique(sort(as.character(metadata.df[,myvar]))))
      # Check if colour column exists already, if not, create
      if (!var_colour_name %in% colnames(metadata.df)) {
        myvar_colours.l <- setNames(discrete_palette[1:length(myvar_values)], myvar_values)
        all_myvar_colours <- as.character(lapply(as.character(metadata.df[,myvar]), function(x) myvar_colours.l[x]))
        metadata.df[,paste0(myvar,"_colour")] <- all_myvar_colours
      }
      # TODO cleanup this section
      metadata_subset.df <- unique(metadata.df[,c(myvar, var_colour_name)])
      # Order by the variable column
      metadata_subset.df <- metadata_subset.df[order(metadata_subset.df[,myvar]),]
      # Factorise the variable column
      metadata_subset.df[,myvar] <- factor(metadata_subset.df[,myvar])
      metadata_subset.df <- metadata_subset.df[!is.na(metadata_subset.df[,myvar]),]
      named_colour_list <- setNames(as.character(metadata_subset.df[, var_colour_name]), as.character(metadata_subset.df[,myvar]))

      colour_lists[[myvar]] <- named_colour_list

    }
  }

  # ------------------------------------------------------------------
  # Assign shapes for each variable
  shape_lists <- list()
  for (myvar in unique(c(discrete_variables, continuous_variables))){
    var_shape_name <- paste0(myvar, "_shape")
    myvar_values <- factor(unique(sort(as.character(metadata.df[,myvar]))))
    if (use_shapes == T){ # If using shapes
      # If no shape column for the variable, assign default pre-defined shapes
      if (!var_shape_name %in% colnames(metadata.df)) {

        if (default_shape_type == "filled") {
          myvar_shapes.l <- setNames(rep(c(25,24,23,22,21),
                                         length(myvar_values))[1:length(myvar_values)],myvar_values)
        } else if (default_shape_type == "hollow") {
          myvar_shapes.l <- setNames(rep(c(6,5,2,1,0),length(myvar_values))[1:length(myvar_values)],myvar_values)
        } else{
          error_message <- paste0("default_shape_type should be either 'filled' or 'hollow'")
          stop(error_message)
        }
      } else { # use shapes in metadata
        temp <- unique(metadata.df[,c(myvar, var_shape_name)])
        myvar_shapes.l <- setNames(temp[,2],temp[,1])
      }
    } else{
      if (default_shape_type == "filled"){
        myvar_shapes.l <- setNames(rep(c(21),length(myvar_values))[1:length(myvar_values)],myvar_values)
      } else if (default_shape_type == "hollow") {
        myvar_shapes.l <- setNames(rep(c(1),length(myvar_values))[1:length(myvar_values)],myvar_values)
      } else{
        error_message <- paste0("default_shape_type should be either 'filled' or 'hollow'")
        stop(error_message)
      }
    }
    all_myvar_shapes <- as.numeric(lapply(as.character(metadata.df[,myvar]), function(x) myvar_shapes.l[x]))
    metadata.df[,paste0(myvar,"_shape")] <- all_myvar_shapes

    # TODO cleanup this section
    metadata_subset.df <- unique(metadata.df[,c(myvar, var_shape_name)])
    # Order by the variable column
    metadata_subset.df <- metadata_subset.df[order(metadata_subset.df[,myvar]),]
    # Factorise the variable column
    metadata_subset.df[,myvar] <- factor(metadata_subset.df[,myvar])
    metadata_subset.df <- metadata_subset.df[!is.na(metadata_subset.df[,myvar]),]
    named_shape_list <- setNames(as.numeric(metadata_subset.df[, var_shape_name]), as.character(metadata_subset.df[,myvar]))
    shape_lists[[myvar]] <- named_shape_list
  }
  if (is.null(shape_variable) | all(!is.null(shape_variable) & use_shapes == F)){

    if (default_shape_type == "filled" & is.null(fill_variable)){
      default_shape <- 16
    } else if (default_shape_type == "filled" & !is.null(fill_variable)){
      default_shape <- 21
    } else if (default_shape_type == "hollow") {
      default_shape <- 1
    } else{
      error_message <- paste0("default_shape_type should be either 'filled' or 'hollow'")
      stop(error_message)
    }
  }
  # TODO handle factorisation. Simply inherit metadata factors? Colour list order does not matter?

  # TODO handle NA in multiple variables, or, is this even required with ggplot?
  # Remove NA entries from the metadata and from the PCA
  # metadata.df <- metadata.df[!is.na(metadata.df[[variable_to_plot]]),]
  # pca_site_scores <- pca_site_scores[rownames(pca_site_scores) %in% rownames(metadata.df),]

  # ------------------------------------------------------------------
  # Calculate PCA percentages
  if (pca_object$method %in% c("rda", "pca", "capscale")){
    pca_percentages <- (pca_object$CA$eig/sum(pca_object$CA$eig)) * 100
  } else if (pca_object$method %in% c("cca")){
    pca_percentages <- (pca_object$CCA$eig/sum(pca_object$CCA$eig)) * 100
  }
  # Assign a percentage of zero to NA values
  pca_percentages[is.na(pca_percentages)] <- 0
  if (length(pca_percentages) == 1){
    pca_percentages[2] <- 0
  }
  # ------------------------------------------------------------------
  my_xlab <- ""
  my_ylab <- ""
  show_x_label = T
  show_y_label = T

  component_choice_name_1 <- colnames(pca_site_scores)[1]
  component_choice_name_2 <- colnames(pca_site_scores)[2]
  if (show_x_label){
    my_xlab = paste(component_choice_name_1,"(", round(pca_percentages[component_choices[1]],1), "%)", sep = "")
  }
  if (show_y_label){
    my_ylab = paste(component_choice_name_2,"(", round(pca_percentages[component_choices[2]],1), "%)", sep = "")
  }

  # -----------------------------------------------------------------------------------------------------------------------
  # -----------------------------------------------------------------------------------------------------------------------
  # Run envfit to calculate fit of variables
  en_coord_cont <- NULL
  en_coord_cat <- NULL

  if (plot_envfit_arrows == T & !is.null(envfit_continuous_variables.v)){
    # Fit environmental (continuous) variables
    en = envfit(pca_object, metadata.df[,envfit_continuous_variables.v,drop =F], permutations = 999, na.rm = TRUE, scaling = 0)
    en_coord_cont <- as.data.frame(scores(en, "vectors")) * ordiArrowMul(as.data.frame(scores(en, "vectors")),rescale =F,display = "sites")
    # en = envfit(pca_object, metadata.df[,continuous_variables,drop =F], permutations = 999, na.rm = TRUE, scaling = )
    # en_coord_cont <- as.data.frame(scores(en, "vectors")) * ordiArrowMul(as.data.frame(scores(en, "vectors",scaling = scaling_choice)),rescale =F,display = "sites")
    # en = envfit(pca_object, metadata.df[,continuous_variables,drop =F], permutations = 999, na.rm = TRUE, scaling = scaling_choice)
    # en_coord_cont <- as.data.frame(scores(en, "vectors")) * ordiArrowMul(as.data.frame(scores(en, "vectors")),rescale =F,display = "sites")
    # en = envfit(pca_object, metadata.df[,continuous_variables,drop =F], permutations = 999, na.rm = TRUE, scaling = 1)
    # en_coord_cont <- as.data.frame(scores(en, "vectors")) * ordiArrowMul(as.data.frame(scores(en, "vectors")),rescale =F,display = "sites")
    # en = envfit(pca_object, metadata.df[,continuous_variables,drop =F], permutations = 999, na.rm = TRUE)
    # en_coord_cont <- as.data.frame(scores(en, "vectors")) * ordiArrowMul(as.data.frame(scores(en, "vectors")),rescale =F,display = "sites")

    # Remove non-significant results
    significant_variables.v <- names(en$vectors$pvals[en$vectors$pvals <= envfit_pvalue_threshold])
    en_coord_cont <- en_coord_cont[significant_variables.v,]
  }
  if (plot_envfit_discrete == T & !is.null(envfit_discrete_variables.v)){
    en = envfit(pca_object, metadata.df[,envfit_discrete_variables.v,drop =F], permutations = 999, na.rm = TRUE, scaling = 0)
    en_coord_cat <- as.data.frame(scores(en, "factors")) * ordiArrowMul(as.data.frame(scores(en, "factors")),rescale =F,display = "sites")
    # en = envfit(pca_object, metadata.df[,discrete_variables,drop =F], permutations = 999, na.rm = TRUE, scaling = scaling_choice)
    # en_coord_cat <- as.data.frame(scores(en, "factors")) * ordiArrowMul(as.data.frame(scores(en, "factors")),rescale =F,display = "sites")
    # en = envfit(pca_object, metadata.df[,discrete_variables,drop =F], permutations = 999, na.rm = TRUE, scaling = 1)
    # en_coord_cat <- as.data.frame(scores(en, "factors")) * ordiArrowMul(as.data.frame(scores(en, "factors")),rescale =F,display = "sites")
    # en = envfit(pca_object, metadata.df[,discrete_variables,drop =F], permutations = 999, na.rm = TRUE)
    # en_coord_cat <- as.data.frame(scores(en, "factors")) * ordiArrowMul(as.data.frame(scores(en, "factors")),rescale =F,display = "sites")

    # Remove non-significant results
    unique_groups_discrete_variables.v <- metadata.df[,envfit_discrete_variables.v,drop =F][,names(en$factors$pvals),drop =F] %>% pivot_longer(., cols = everything()) %>% dplyr::select(value) %>% unique() %>% pull()
    en_coord_cat_row_variables.v <- gsub(paste0(unique_groups_discrete_variables.v, collapse = "$|"), "",rownames(en_coord_cat))
    significant_variables.v <- names(en$factors$pvals[en$factors$pvals <= envfit_pvalue_threshold])

    en_coord_cat <- en_coord_cat[en_coord_cat_row_variables.v %in% significant_variables.v,]
    pattern <- paste0("^",envfit_discrete_variables.v,collapse = "|")
    # rownames(en_coord_cat) <- gsub(pattern, "", rownames(en_coord_cat))
    rownames(en_coord_cat) <- gsub(paste0("(", pattern, ")"), "\\1:", rownames(en_coord_cat))
  }
  # -----------------------------------------------------------------------------------------------------------------------
  # -----------------------------------------------------------------------------------------------------------------------
  # Get a list of the 'top' species and generate corresponding PC dataframe
  # FIXME better handling of if no top species etc.

  top_vars.v <- NULL
  if (num_top_species > 0 & is.null(pca_specie_scores) == F){
    if (top_species_by_score == T){
      left_pc1.v <- rownames(pca_specie_scores[order(pca_specie_scores[,1]),][1:num_top_species,])
      right_pc1.v <- rownames(pca_specie_scores[order(pca_specie_scores[,1]),][(length(pca_specie_scores[,1]) - num_top_species):length(pca_specie_scores[,1]),])
      left_pc2.v <- rownames(pca_specie_scores[order(pca_specie_scores[,2]),][1:num_top_species,])
      right_pc2.v <- rownames(pca_specie_scores[order(pca_specie_scores[,2]),][(length(pca_specie_scores[,2]) - num_top_species):length(pca_specie_scores[,2]),])
      top_vars.v <- unique(c(left_pc1.v, right_pc1.v, left_pc2.v, right_pc2.v))
    }
    if (top_species_by_contribution == T){
      species_contribution_scores <- vegan::scores(pca_object, display = "species", choices = component_choices, scaling = 0)
      top_vars.v <- unique(c(top_vars.v, names(sort(species_contribution_scores[,1]^2,decreasing = T))[1:num_top_species]))
      top_vars.v <- unique(c(top_vars.v, names(sort(species_contribution_scores[,2]^2,decreasing = T))[1:num_top_species]))
    }
  }

  # Also, included specified species
  if (!is.null(species_to_include.v) & !is.null(pca_specie_scores) == T){
    if (!all(species_to_include.v %in% rownames(pca_specie_scores))){
      warning("Not all specified species are in the ordination object, skipping.")
    } else{
      top_vars.v <- unique(c(top_vars.v, species_to_include.v))
      # print(top_vars.v)
    }
  }

  # Generate specie coordinate dataframe
  if (!is.null(pca_specie_scores)){
    pca_specie_data__unfiltered.df <- m2df(pca_specie_scores, "Species")
    pca_specie_data__unfiltered.df[,2] <- pca_specie_data__unfiltered.df[,2] * specie_arrow_scalar
    pca_specie_data__unfiltered.df[,3] <- pca_specie_data__unfiltered.df[,3] * specie_arrow_scalar
    pca_specie_data.df <- m2df(pca_specie_scores[top_vars.v,,drop =F], "Species")
    pca_specie_data.df[,2] <- pca_specie_data.df[,2] * specie_arrow_scalar
    pca_specie_data.df[,3] <- pca_specie_data.df[,3] * specie_arrow_scalar
  } else{
    pca_specie_data.df <- NULL
  }

  # print(pca_specie_data.df)
  # ------------------------------------------------------------------

  # Combine the site scores with the metadata
  pca_data.df <- left_join(m2df(pca_site_scores, "_site_name"), metadata.df, "_site_name")
  pca_axis_names.v <- colnames(pca_site_scores)
  # names(pca_data.df)[2] <- "PC1"
  # names(pca_data.df)[3] <- "PC2"
  # Generate plot
  myplot <-
    ggplot(pca_data.df, aes_string(x = component_choice_name_1, y = component_choice_name_2))

  if (highlight_origin == T){
    myplot <-
      myplot +
      geom_hline(aes(yintercept = 0), colour = "grey40", lty = 2) +
      geom_vline(aes(xintercept = 0), colour = "grey40", lty = 2)
  }

  if (plot_specie_points == T && !is.null(pca_specie_data.df) && dim(pca_specie_data.df)[1] != 0 ){
    # Currently using all species data, unfiltered
    myplot <-
      myplot +
      geom_point(data = pca_specie_data__unfiltered.df,
                 colour = species_point_colour,
                 fill = species_point_fill_colour,
                 shape = species_point_shape,
                 size = species_point_size,
                 alpha = species_point_alpha,
                 stroke = species_point_line_thickness)
  }

  # Shape
  # FIXME if colour/shape are not the same as shape, shape should be hollow form and not coloured??
  if (use_shapes == T & !is.null(shape_variable)){
    if (!is.null(colour_variable) & !is.null(fill_variable)){
      myplot <-
        myplot +
        geom_point(aes_string(colour = colour_variable, fill = fill_variable, shape = shape_variable), size = point_size,alpha = point_alpha, stroke = point_line_thickness) +
        scale_shape_manual(values = shape_lists[[shape_variable]], name = shape_variable)
    } else if (!is.null(colour_variable) & is.null(fill_variable)){
      myplot <-
        myplot +
        geom_point(aes_string(colour = colour_variable, shape = shape_variable), fill = "black", size = point_size,alpha = point_alpha, stroke = point_line_thickness) +
        scale_shape_manual(values = shape_lists[[shape_variable]], name = shape_variable)
    } else if (is.null(colour_variable) & !is.null(fill_variable)){
      myplot <-
        myplot +
        geom_point(aes_string(fill = fill_variable, shape = shape_variable), colour = "black", size = point_size,alpha = point_alpha, stroke = point_line_thickness) +
        scale_shape_manual(values = shape_lists[[shape_variable]], name = shape_variable)
    }
  } else {
    myplot <-
      myplot +
      geom_point(
        aes_string(colour = colour_variable,fill = fill_variable),
        shape = default_shape, size = point_size, stroke = point_line_thickness, alpha = point_alpha
      )
  }

  myplot <-
    myplot +
    xlab(my_xlab) +
    ylab(my_ylab)

  if (label_sites == T){
    if (is.null(site_label_variable)){
      myplot <- myplot +
        # geom_text(aes_string(x = component_choice_name_1, y = component_choice_name_2, label = "`_site_name`"),
        #           size = site_label_size, fontface = site_label_font_type, colour = site_label_colour)
        ggrepel::geom_text_repel(aes_string(x = component_choice_name_1, y = component_choice_name_2, label = "`_site_name`"),#,colour = "black",
                                 fontface = site_label_font_type,
                                 colour = site_label_colour,
                                 # alpha = envfit_arrow_label_alpha,
                                 size = site_label_size,
                                 max.overlaps = Inf,
                                 segment.color = 'black',
                                 box.padding = 0,
                                 segment.size = .2, # min.segment.length = 0,
                                 # arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                                 point.padding = unit(0, "cm"),
                                 show.legend  = F,
                                 nudge_x = .0,
                                 nudge_y = .0
        )
    } else{
      myplot <- myplot +
        # geom_text(aes_string(x = component_choice_name_1, y = component_choice_name_2, label = site_label_variable),
        #           size = site_label_size, fontface = site_label_font_type, colour = site_label_colour)
        ggrepel::geom_text_repel(aes_string(x = component_choice_name_1, y = component_choice_name_2, label = site_label_variable),#,colour = "black",
                                 fontface = site_label_font_type,
                                 colour = site_label_colour,
                                 # alpha = envfit_arrow_label_alpha,
                                 size = site_label_size,
                                 max.overlaps = Inf,
                                 segment.color = 'black',
                                 box.padding = 0,
                                 segment.size = .2, # min.segment.length = 0,
                                 # arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                                 point.padding = unit(0, "cm"),
                                 show.legend  = F,
                                 nudge_x = .0,
                                 nudge_y = .0
        )

    }
  }

  # Colour
  if (all(!is.null(colour_variable) && colour_variable %in% envfit_continuous_variables.v)){
    colour_variable_colours <- colour_lists[[colour_variable]][["colour_function"]](colour_lists[[colour_variable]][["colour_breaks"]])
    myplot <-
      myplot +
      scale_colour_gradientn(colours = colour_variable_colours, name = colour_variable)
  } else if(all(!is.null(colour_variable) && colour_variable %in% envfit_discrete_variables.v)) {
    colour_variable_colours <- colour_lists[[colour_variable]]
    myplot <-
      myplot +
      scale_colour_manual(values = colour_variable_colours, name = colour_variable)
    if(all(is.null(shape_variable) || shape_variable != colour_variable)){
      myplot +
        guides(colour = guide_legend(override.aes = list(shape = 21)))
    }
  } else{
    myplot <-
      myplot #+
    # scale_colour_manual(values = "grey", name = colour_variable)
  }


  # Fill
  if (all(!is.null(fill_variable) && fill_variable %in% envfit_continuous_variables.v)){
    fill_variable_colours <- colour_lists[[fill_variable]][["colour_function"]](colour_lists[[fill_variable]][["colour_breaks"]])
    myplot <-
      myplot +
      scale_fill_gradientn(colours = fill_variable_colours, name = fill_variable)
  } else if (!is.null(fill_variable) && fill_variable %in% envfit_discrete_variables.v) {
    myplot <-
      myplot +
      scale_fill_manual(values = colour_lists[[fill_variable]], name = fill_variable)
    if(all(is.null(shape_variable) || shape_variable != fill_variable)){
      myplot <-
        myplot +
        guides(fill = guide_legend(override.aes = list(shape = 21)))
    }
  } else{
    myplot <-
      myplot #+
    # scale_fill_manual(values = "grey", name = fill_variable)
  }

  # Hulls
  if (plot_hulls == T & !is.null(hull_variable)){
    hull_data.df <- pca_data.df %>%
      dplyr::group_by_at(hull_variable) %>%
      slice(chull(get(component_choice_name_1), get(component_choice_name_2)))
    hull_outlines.l <- unlist(lapply(colour_lists[hull_variable], darken))
    names(hull_outlines.l) <- names(colour_lists[[hull_variable]])

    hull_centers.df <-
      pca_data.df %>%
      dplyr::select(component_choice_name_1, component_choice_name_2, hull_variable) %>%
      dplyr::group_by_at(hull_variable) %>%
      dplyr::mutate(cntr.x = mean(get(component_choice_name_1)), cntr.y = mean(get(component_choice_name_2))) %>%
      as.data.frame()


    myplot <-
      myplot +
      ggnewscale::new_scale_fill() +
      scale_fill_manual(values = ggplot2::alpha(colour_lists[[hull_variable]], hull_fill_alpha), name = hull_variable) +
      ggnewscale::new_scale_colour() +
      scale_colour_manual(values = ggplot2::alpha(hull_outlines.l, hull_outline_alpha), name = hull_variable) +
      geom_polygon(data = hull_data.df, aes_string(fill = hull_variable, colour = hull_variable), size = hull_border_width,show.legend = FALSE)

    if (label_hulls == T){
      temp <- unique(hull_centers.df[,c(hull_variable, "cntr.x","cntr.y")])
      myplot <-
        myplot +
        geom_text(data = temp, aes_string(x = "cntr.x", y = "cntr.y", label = hull_variable),
                  colour = hull_label_colour,
                  fontface = hull_label_font_type,
                  size= hull_label_size)
      # annotate("text",x=temp$cntr.x,y=temp$cntr.y,label=temp[,hull_variable])
    }
  }

  # Ellipses
  if (plot_ellipses == T & !is.null(ellipse_variable)){
    # useful: https://stackoverflow.com/questions/42799838/follow-up-plotting-ordiellipse-function-from-vegan-package-onto-nmds-plot-creat
    veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100){
      theta <- (0:npoints) * 2 * pi/npoints
      Circle <- cbind(cos(theta), sin(theta))
      t(center + scale * t(Circle %*% chol(cov)))
    }

    # TODO clean this up
    # ellipse_data.df <- aggregate(pca_data.df[,c("PC1","PC2")], by=list(pca_data.df[,ellipse_variable]),mean)    # c
    # colnames(ellipse_data.df) <- c(ellipse_variable, "x", "y")
    rslt <- vegan::ordiellipse(pca_object,
                               groups = metadata.df[,ellipse_variable],
                               display = "sites",
                               choices=component_choices, kind = "ehull", draw = "none", label = label_ellipse, cex = ellipse_label_size,)
    # Get points to plot for the ellipses.
    df_ord <- pca_data.df[,c("_site_name", component_choice_name_1, component_choice_name_2, ellipse_variable)] # FIXME PC# hardcoding
    ellipse_data.df <- data.frame()
    ellipse_mean = aggregate(df_ord[,2:3],list(group=df_ord[,ellipse_variable]),mean)
    for(group in unique(pca_data.df[,ellipse_variable])) {
      # ellipse_data.df <- rbind(ellipse_data.df, cbind(as.data.frame(with(df_ord[df_ord$`ellipse_variable` == group,],
      #                                                                    vegan:::veganCovEllipse(rslt[[group]]$cov,
      #                                                                                            rslt[[group]]$center,
      #                                                                                            rslt[[group]]$scale))),
      #                                                 Group=group))

      ellipse_data.df <- rbind(ellipse_data.df, cbind(as.data.frame(with(df_ord[df_ord[,ellipse_variable] == group,],
                                                                         veganCovEllipse(
                                                                           # cov = cov.wt(cbind(PC1,PC2),
                                                                           #              wt=rep(1/length(PC1),length(PC1))
                                                                           #              )$cov,
                                                                           cov = rslt[[group]]$cov,
                                                                           center=c(mean(PC1),mean(PC2)),
                                                                           # center = rslt[[group]]$center,
                                                                           scale = rslt[[group]]$scale
                                                                         ))),
                                                      Group=group))

      # print(df_ord)
      # print(component_choice_name_1)
      # print(head(ellipse_data.df))
      # ellipse_data.df <- rbind(ellipse_data.df, cbind(as.data.frame(with(df_ord[df_ord[,ellipse_variable] == group,],
      #                                                                    veganCovEllipse(
      #                                                                      # cov = cov.wt(cbind(PC1,PC2),
      #                                                                      #              wt=rep(1/length(PC1),length(PC1))
      #                                                                      #              )$cov,
      #                                                                      cov = rslt[[group]]$cov,
      #                                                                      center=c(mean(component_choice_name_1),mean(component_choice_name_2)),
      #                                                                      # center = rslt[[group]]$center,
      #                                                                      scale = rslt[[group]]$scale
      #                                                                    ))),
      #                                                 Group=group))
    }

    names(ellipse_data.df) <- c("x", "y", ellipse_variable)
    colour_variable_colours <- colour_lists[[ellipse_variable]]

    myplot <-
      myplot +
      ggnewscale::new_scale_color() +
      geom_path(data = ellipse_data.df, aes_string(x="x", y="y", colour = ellipse_variable), show.legend = FALSE) +
      scale_colour_manual(values = ggplot2::alpha(colour_variable_colours, alpha = ellipse_alpha), name = ellipse_alpha)
    if (label_ellipse == T){
      myplot <-
        myplot +
        annotate("text",x=ellipse_mean[,2],y=ellipse_mean[,3],label=ellipse_mean$group)
    }
  }

  if (plot_spiders == T & !is.null(spider_variable)){
    spider_data.df <-
      pca_data.df %>%
      dplyr::select(component_choice_name_1, component_choice_name_2, spider_variable) %>%
      dplyr::group_by_at(spider_variable) %>%
      dplyr::mutate(cntr.x = mean(get(component_choice_name_1)), cntr.y = mean(get(component_choice_name_2))) %>%
      as.data.frame()

    colour_variable_colours <- colour_lists[[spider_variable]]
    myplot <-
      myplot +
      ggnewscale::new_scale_colour() +
      geom_segment(data=spider_data.df, aes_string(x="cntr.x",
                                                   xend=component_choice_name_1,
                                                   y="cntr.y",
                                                   yend=component_choice_name_2,
                                                   colour = spider_variable),
                   linewidth = spider_line_width) +
      scale_colour_manual(values = ggplot2::alpha(colour_variable_colours, alpha = spider_alpha), name = spider_variable)

    if (label_spider == T){
      temp <- unique(spider_data.df[,c(spider_variable, "cntr.x","cntr.y")])
      myplot <-
        myplot +
        # annotate("text",x=temp$cntr.x,y=temp$cntr.y,label=temp[,spider_variable]) +
        geom_text(data = temp, aes_string(x = "cntr.x", y = "cntr.y", label = spider_variable),
                  colour = spider_label_colour,
                  fontface = spider_label_font_type,
                  size = spider_label_size)
    }

  }

  if (plot_envfit_arrows == T & !is.null(envfit_continuous_variables.v) & !is.null(en_coord_cont) && dim(en_coord_cont)[1] != 0){
    # see https://github.com/gavinsimpson/ggvegan/blob/4bc6ee9945dd9229ed486409c0acab9413b8c9af/R/autoplot.envfit.R
    en_coord_cont[,c(component_choice_name_1,component_choice_name_2)] <-
      en_coord_cont[,c(component_choice_name_1,component_choice_name_2)] * envfit_arrow_scalar
    myplot <-
      myplot +
      geom_segment(data = en_coord_cont, aes_string(x = 0, y = 0,
                                                    xend = component_choice_name_1,
                                                    yend = component_choice_name_2) ,
                   arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                   colour = envfit_arrow_colour,
                   lty = envfit_arrow_linetype,
                   linewidth = envfit_arrow_thickness,
                   alpha = envfit_arrow_alpha)
    en_coord_cont__for_text <- en_coord_cont[,c(component_choice_name_1,component_choice_name_2)]/envfit_arrow_scalar*envfit_arrow_label_scalar
    if (envfit_arrow_label_type == "text"){
      myplot <-
        myplot +
        # geom_text(data = en_coord_cont__for_text, aes_string(x = component_choice_name_1, y = component_choice_name_2),
        #           colour = envfit_arrow_label_colour,
        #           size = envfit_arrow_label_size, fontface = envfit_arrow_label_font_type,
        #           label = row.names(en_coord_cont)) +
        ggrepel::geom_text_repel(data = en_coord_cont__for_text, aes_string(x = component_choice_name_1, y = component_choice_name_2),#,colour = "black",
                                 label = row.names(en_coord_cont),
                                 fontface = envfit_arrow_label_font_type,
                                 colour = envfit_arrow_label_colour,
                                 alpha = envfit_arrow_label_alpha,
                                 size = envfit_arrow_label_size,
                                 max.overlaps = Inf,
                                 segment.color = 'black',
                                 box.padding = 0,
                                 segment.size = .2, # min.segment.length = 0,
                                 arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                                 point.padding = unit(0, "cm"),
                                 show.legend  = F,
                                 nudge_x = .0,
                                 nudge_y = .0
        )
    } else if (envfit_arrow_label_type == "label"){
      myplot <-
        myplot +
        # ggrepel::geom_label_repel(data = en_coord_cont, aes_string(x = component_choice_name_1, y = component_choice_name_2 ),
        #                           label = row.names(en_coord_cont),
        #                           size = envfit_arrow_label_size, fontface = envfit_arrow_label_font_type,
        #                           colour = envfit_arrow_label_colour,
        #                           fill = envfit_arrow_label_fill_colour, alpha = envfit_arrow_label_alpha,
        #                           label.size = 0.25, force_pull = 10,
        #                           # position = position_dodge(0.9),
        #                           nudge_x = 0, nudge_y = 0)
        # geom_label(data = en_coord_cont, aes_string(x = component_choice_name_1, y = component_choice_name_2 ),
        #            label = row.names(en_coord_cont),
        #            size = envfit_arrow_label_size, fontface = envfit_arrow_label_font_type,
        #            colour = envfit_arrow_label_colour,
        #            fill = envfit_arrow_label_fill_colour, alpha = envfit_arrow_label_alpha,
        #            label.size = 0.25,
        #            # position = position_dodge(0.9),
        #            nudge_x = 0, nudge_y = 0,label.padding = unit(0.1,"lines"))
        ggrepel::geom_label_repel(data = en_coord_cont__for_text, aes_string(x = component_choice_name_1, y = component_choice_name_2),#,colour = "black",
                                  fill = envfit_arrow_label_fill_colour,
                                  label = row.names(en_coord_cont),
                                  fontface = envfit_arrow_label_font_type,
                                  colour = envfit_arrow_label_colour,
                                  alpha = envfit_arrow_label_alpha,
                                  size = envfit_arrow_label_size,
                                  label.size = NA,
                                  max.overlaps = Inf,
                                  segment.color = 'black',
                                  label.padding = unit(0.1,"lines"),
                                  box.padding = 0,
                                  segment.size = .2, # min.segment.length = 0,
                                  arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                                  point.padding = unit(0, "cm"),
                                  show.legend  = F,
                                  nudge_x = .0,
                                  nudge_y = .0
        )
    }

  }

  if (plot_envfit_discrete == T & !is.null(en_coord_cat) && dim(en_coord_cat)[1] != 0){
    en_coord_cat[,c(component_choice_name_1,component_choice_name_2)] <-
      en_coord_cat[,c(component_choice_name_1,component_choice_name_2)] * envfit_discrete_scalar
    if (envfit_discrete_label_type == "text"){
      myplot <-
        myplot +
        geom_text(data = en_coord_cat, aes_string(x = component_choice_name_1, y = component_choice_name_2),
                  colour = envfit_discrete_label_colour,
                  fontface = envfit_discrete_label_font_type,
                  label = row.names(en_coord_cat),
                  size = envfit_discrete_label_size)
    } else if (envfit_discrete_label_type == "label"){
      myplot <-
        myplot +
        # ggrepel::geom_label_repel(data = en_coord_cat, aes_string(x = component_choice_name_1, y = component_choice_name_2 ),
        #                           label = row.names(en_coord_cat),
        #                           size = envfit_discrete_label_size, fontface = envfit_discrete_label_font_type,
        #                           colour = envfit_discrete_label_colour,
        #                           fill = envfit_discrete_label_fill_colour, alpha = envfit_discrete_label_alpha,
        #                           label.size = 0.25, max.overlaps = 20,
        #                           # position = position_dodge(0.9),
        #                           nudge_x = 0, nudge_y = 0)
        geom_label(data = en_coord_cat, aes_string(x = component_choice_name_1, y = component_choice_name_2 ),
                   label = row.names(en_coord_cat),
                   size = envfit_discrete_label_size, fontface = envfit_discrete_label_font_type,
                   colour = envfit_discrete_label_colour,
                   fill = envfit_discrete_label_fill_colour, alpha = envfit_discrete_label_alpha,
                   label.size = 0.25,
                   # position = position_dodge(0.9),
                   nudge_x = 0, nudge_y = 0,label.padding = unit(0.1,"lines"))
    }
  }

  # TODO handle biplot discrete and continuous separately, same as envfit
  # Would be nice to be able to combine the two
  if (plot_biplot == T & !is.null(biplot.df) && dim(biplot.df)[1] != 0){
    biplot.df[,c("Biplot1","Biplot2")] <-
      biplot.df[,c("Biplot1","Biplot2")] * envfit_arrow_scalar # use this scalar for now
    myplot <-
      myplot +
      geom_segment(data = biplot.df, aes_string(x = 0, y = 0,
                                                xend = "Biplot1",
                                                yend = "Biplot2") ,
                   arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                   colour = envfit_arrow_colour,
                   lty = envfit_arrow_linetype,
                   linewidth = envfit_arrow_thickness,
                   alpha = envfit_arrow_alpha)
    biplot_for_text.df <- biplot.df[,c("Biplot1","Biplot2")]/envfit_arrow_scalar*envfit_arrow_label_scalar
    if (biplot_label_type == "text"){
      myplot <-
        myplot +
        ggrepel::geom_text_repel(data = biplot_for_text.df, aes_string(x = "Biplot1", y = "Biplot2"),#,colour = "black",
                                 label = row.names(biplot_for_text.df),
                                 fontface = envfit_arrow_label_font_type,
                                 colour = envfit_arrow_label_colour,
                                 alpha = envfit_arrow_label_alpha,
                                 size = envfit_arrow_label_size,
                                 max.overlaps = Inf,
                                 segment.color = 'black',
                                 box.padding = 0,
                                 segment.size = .2, # min.segment.length = 0,
                                 arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                                 point.padding = unit(0, "cm"),
                                 show.legend  = F,
                                 nudge_x = .0,
                                 nudge_y = .0
        )
      # geom_text(data = en_coord_cat, aes_string(x = component_choice_name_1, y = component_choice_name_2),
      #           colour = envfit_discrete_label_colour,
      #           fontface = envfit_discrete_label_font_type,
      #           label = row.names(en_coord_cat),
      #           size = envfit_discrete_label_size)
    } else if (biplot_label_type == "label"){
      myplot <-
        myplot +
        ggrepel::geom_label_repel(data = biplot_for_text.df, aes_string(x = "Biplot1", y = "Biplot2"),#,colour = "black",
                                  fill = envfit_arrow_label_fill_colour,
                                  label = row.names(biplot_for_text.df),
                                  fontface = envfit_arrow_label_font_type,
                                  colour = envfit_arrow_label_colour,
                                  alpha = envfit_arrow_label_alpha,
                                  size = envfit_arrow_label_size,
                                  label.size = NA,
                                  max.overlaps = Inf,
                                  segment.color = 'black',
                                  label.padding = unit(0.1,"lines"),
                                  box.padding = 0,
                                  # label.r = 0,
                                  # force_pull = 10,
                                  segment.size = .2, # min.segment.length = 0,
                                  arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                                  point.padding = unit(0, "cm"),
                                  show.legend  = F,
                                  nudge_x = .0,
                                  nudge_y = .0
        )
    }
  }
  if (plot_specie_arrows == T && !is.null(pca_specie_data.df) && dim(pca_specie_data.df)[1] != 0 ){
    myplot <-
      myplot +
      # geom_point(data = pca_specie_data.df,aes(x = PC1*2, y = PC2*2), shape = 22, colour = specie_arrow_colour) +
      geom_segment(data = pca_specie_data.df, aes_string(x = 0, y = 0, xend = component_choice_name_1, yend = component_choice_name_2),
                   arrow = arrow(length = unit(specie_arrow_head_size, 'cm'),type = "closed",angle = 15),
                   colour = specie_arrow_colour,
                   lty = specie_arrow_linetype,
                   linewidth = specie_arrow_thickness,
                   alpha = specie_arrow_alpha)
    if (label_specie_arrows == T){
      if (!is.null(specie_labeller_function)){
        pca_specie_data.df$Species_label <- as.character(unlist(lapply(pca_specie_data.df$Species, specie_labeller_function)))
      } else{
        pca_specie_data.df$Species_label <- pca_specie_data.df$Species
      }
      if (specie_arrow_label_type == "text"){
        myplot <-
          myplot +
          # geom_text(data = pca_specie_data.df,aes_string(x = component_choice_name_1, y = component_choice_name_2, label = "Species_label"),
          #           size= specie_arrow_label_size, fontface = specie_arrow_label_font_type, alpha = specie_arrow_label_alpha,
          #           colour = specie_arrow_label_colour,
          #           check_overlap = F,
          #           # position = position_dodge(0.9),
          #           nudge_x = 0, nudge_y = 0
          #           # nudge_x = runif(1,0.1,.2), nudge_y = runif(1,0.1,.2)
          # )
          # ggrepel::geom_text_repel(data = pca_specie_data.df,aes_string(x = component_choice_name_1, y = component_choice_name_2, label = "Species_label"),
          #                          size= specie_arrow_label_size, fontface = specie_arrow_label_font_type, alpha = specie_arrow_label_alpha,
          #                          colour = specie_arrow_label_colour,
          #                          # position = position_dodge(0.9),
          #                          nudge_x = 0.0, nudge_y = 0.0,segment.size = .5,max.overlaps = Inf)
          ggrepel::geom_text_repel(data = pca_specie_data.df, aes_string(x = component_choice_name_1, y = component_choice_name_2, label = "Species_label"),#,colour = "black",
                                   fontface = specie_arrow_label_font_type,
                                   colour = specie_arrow_label_colour,
                                   alpha = specie_arrow_label_alpha,
                                   size = specie_arrow_label_size,
                                   max.overlaps = Inf,
                                   segment.color = 'black',
                                   box.padding = 0,
                                   segment.size = .2, # min.segment.length = 0,
                                   # arrow = arrow(length = unit(envfit_arrow_head_size, 'cm'),type = "closed",angle = 15),
                                   point.padding = unit(0, "cm"),
                                   show.legend  = F,
                                   nudge_x = .0,
                                   nudge_y = .0
          )
      } else if (specie_arrow_label_type == "label"){
        myplot <-
          myplot +
          geom_label(data = pca_specie_data.df,aes_string(x = component_choice_name_1, y = component_choice_name_2, label = "Species_label"),
                     size=specie_arrow_label_size, fontface = specie_arrow_label_font_type,
                     colour = specie_arrow_label_colour,
                     fill = specie_arrow_label_fill_colour, alpha = specie_arrow_label_alpha,
                     label.size = 0.25,
                     # position = position_dodge(0.9),
                     nudge_x = 0, nudge_y = 0
          )
      } #TODO geom_label_repel?
    }

  }

  myplot
}


generate_pca <- function(pca_object, # PCA object generated by the rda() function from vegan package
                         metadata.df, # Dataframe containing metadata
                         variable_to_plot, # Variable (column) that we are plotting
                         variable_colours_available = F,
                         my_colour_palette = NULL,
                         my_levels = NULL,

                         axis_limits = NULL, # list of axes limits c(xmin, xmax,ymin,ymax)
                         hide_grid = F, # Hide the grid
                         highlight_origin = T, # Highlight the origin line
                         show_x_label = T, # Show x-axis label
                         show_y_label = T, # Show y-axis label
                         plot_x_ticks = T, # Show x-axis tick marks
                         plot_y_ticks = T, # Show y-axis tick marks
                         plot_x_tick_labels = T, # Show x-axis tick labels
                         plot_y_tick_labels = T, # Show x-axis tick labels
                         plot_title = NULL, # Show plot title
                         title_cex = 1, # Size of title

                         component_choices = c(1,2),

                         plot_arrows = F, # Show contributing species/OTUs vectors
                         num_top_species = 5, # How many species/OTUs to show with the largest contributions to the variance
                         arrow_colour = "black", # Color of arrows
                         arrow_alpha = 1, # Transparency of arrows, 0 = invisible, 1= fully, visible, 0.5 = 50% transparent
                         arrow_thickness = .2, # Thickness of arrow
                         label_arrows=T, # Label the arrows
                         arrow_label_size = .5, # Size of arrow label
                         arrow_scalar = 1, # Scale of the arrows
                         arrow_label_colour = "black", # Colour of arrow label
                         arrow_label_font_type = 1, # Font type of arrow label : 1 Normal, 2 bold, 3 italic, 4 bold italic
                         arrow_label_offset = 0, # How much to offset the arrow label
                         arrow_label_alpha = 1, # The transparency of the arrow labels

                         seed = NULL, # Set random seed

                         plot_hulls = F, # Plot hulls
                         hull_alpha = 1, # The transparency of the hulls

                         plot_spiders = F, # Plot spiders
                         label_spider = F, # Label the spider centroid
                         spider_label_size = 0.5, # Size of spider label
                         spider_alpha = 1, # The transparency of the spiders

                         plot_ellipses = F, # Plot ellipse
                         label_ellipse = F, # Label ellipse
                         ellipse_label_size = 0.5, # Size of ellipse label
                         ellipse_border_width = 1, # Width of ellipse border
                         ellipse_alpha = 1, # The transparency of the ellipses


                         label_sites = F, # Label the individual sites/samples
                         label_species = F, # Label the individual species/OTUs

                         point_alpha = 1, # Transparency of points, 0 = invisible, 1= fully, visible, 0.5 = 50% transparent
                         point_size = 0.8, # Size of points
                         point_line_thickness = 1, # Thickness of point outline
                         point_line_is_darker_fill = F, # Use a darkened version of the point fill colour as outline colour
                         use_shapes = T,
                         variable_shapes_available = F,
                         use_fill_shapes = T, # Whether to use fill shapes or hollow shapes

                         include_legend = T, # Show the legend
                         legend_x = NULL, # x axis position of legend
                         legend_y = NULL, # y axis position of legend
                         legend_x_offset = 0, # How much to offset the legend on the x axis (assumes legend_x = NULL)
                         legend_y_offset = 0, # How much to offset the legend on the y axis (assumes legend_y = NULL)
                         legend_cex = 0.6, # Size of text in legend
                         legend_columns = 2, # Number of columns used for legend key
                         legend_key_text_distance = 0.5, # Distance between legend keys and text
                         legend_column_spacing = 0.5, # Distance between legend columns
                         legend_title = NULL, # Title of the legend. If NULL, just uses the variable
                         legend_fill_colour = NULL,
                         specie_labeller_function = NULL, # Function to re-label the species/OTUs,

                         is_constrained = F, # This is a constrained ordination object

                         file_type = "pdf",
                         filename = NULL,
                         plot_width = 10,
                         plot_height= 10
){
  # Function to generate a PCA plot
  if (!is.null(seed)){
    set.seed(seed)
  }
  pca.scores <- try(scores(pca_object, choices=c(1,2,3)))
  if(inherits(pca.scores, "try-error")) {
    return()
  }
  # Get component x,y coordinates
  pca_site_scores <- scores(pca_object, display = "sites", choices = component_choices)
  pca_specie_scores <- scores(pca_object, display = "species", choices = component_choices)

  # Check all entries in the PCA object are also in the metadata
  if (!all(rownames(pca_site_scores) %in% rownames(metadata.df))){
    error_message <- paste0("There are rows in the PCA object that are not defined in the metadata.
                             Rownames in the metadata need to match those used in the PCA object")
    stop(error_message)
  }
  # Remove NA entries from the metadata and from the PCA
  metadata.df <- metadata.df[!is.na(metadata.df[[variable_to_plot]]),]
  pca_site_scores <- pca_site_scores[rownames(pca_site_scores) %in% rownames(metadata.df),]

  if (is_constrained){
    pca_percentages <- (pca_object$CCA$eig/sum(pca_object$CCA$eig)) * 100
  } else{
    pca_percentages <- (pca_object$CA$eig/sum(pca_object$CA$eig)) * 100
  }

  # Assign a percentage of zero to NA values
  pca_percentages[is.na(pca_percentages)] <- 0
  if (length(pca_percentages) == 1){
    pca_percentages[2] <- 0
  }

  if (!is.null(axis_limits)){
    x_min <- axis_limits[1]
    x_max <- axis_limits[2]
    y_min <- axis_limits[3]
    y_max <- axis_limits[4]
  }else {
    x_min <- round(lapply(min(pca_site_scores[,1]), function(x) ifelse(x > 0, x + 1, x - 1))[[1]])
    x_max <- round(lapply(max(pca_site_scores[,1]), function(x) ifelse(x > 0, x + 1, x - 1))[[1]])
    y_min <- round(lapply(min(pca_site_scores[,2]), function(x) ifelse(x > 0, x + 1, x - 1))[[1]])
    y_max <- round(lapply(max(pca_site_scores[,2]), function(x) ifelse(x > 0, x + 1, x - 1))[[1]])

  }
  my_xlab <- ""
  my_ylab <- ""
  if (show_x_label){
    my_xlab = paste("PC",component_choices[1],"(", round(pca_percentages[component_choices[1]],1), "%)", sep = "")
  }
  if (show_y_label){
    my_ylab = paste("PC", component_choices[2],"(", round(pca_percentages[component_choices[2]],1), "%)", sep = "")
  }

  metadata.df <- metadata.df[order(rownames(metadata.df)),]
  metadata.df <- metadata.df[order(metadata.df[[variable_to_plot]]),]

  # ------------------------------------------------------------------------------------
  # Ensure outcome variable is factored
  # Refactor the variable column so that the levels are consistent
  if (!is.null(my_levels)){
    metadata.df[,variable_to_plot] <- factor(metadata.df[,variable_to_plot], levels = my_levels)
  } else{
    # Uncomment to factorise and order levels alphabetically
    metadata.df[,variable_to_plot] <- factor(metadata.df[,variable_to_plot],
                                             levels = sort(unique(as.character(metadata.df[,variable_to_plot]))))
    # Uncomment to factorise and inherit the current ordering
    # metadata.df[,variable_to_plot] <- factor(metadata.df[,variable_to_plot])
  }
  # ------------------------------------------------------------------------------------


  if (!is.null(filename)){
    if (file_type == "pdf"){
      pdf(file = filename,height = plot_height, width = plot_width)
    } else if (file_type == "svg"){
      # Cairo::CairoSVG(file = filename,width = plot_width,height = plot_height)
      svg(filename = filename,height = plot_height, width = plot_width)
      # svglite(file = filename,height = plot_height, width = plot_width)
    }
  }


  # dataframe.df <- dataframe.df[order(rownames(dataframe.df)),,drop = F]
  # dataframe.df <- dataframe.df[order(dataframe.df[[variable_to_plot]]),,drop = F]
  # dataframe.df[,variable_to_plot] <- factor(dataframe.df[,variable_to_plot],
  #                                           levels = sort(unique(as.character(dataframe.df[,variable_to_plot]))))
  plot(0,
       type='n',
       # x = 0, y=0,
       xlim = c(x_min,x_max),
       ylim = c(y_min,y_max),
       xlab = my_xlab,
       ylab = my_ylab,
       xaxt = "n",
       yaxt = "n",
       # frame.plot = F,
       frame.plot = T
  )
  # Make grid
  if (hide_grid == F){
    grid(NULL,NULL, lty = 2, lwd = 1, col = "grey80")
  }
  if (highlight_origin == T){
    abline(v = 0, h = 0, col="grey40", lty = 2,lwd = 1)
  }


  # Add axes
  axis(side = 1, labels = ifelse(plot_x_tick_labels, T, F), tck = -0.01,tick = ifelse(plot_x_ticks,T,F))
  axis(side = 2, labels = ifelse(plot_y_tick_labels, T, F), tck = -0.01, tick = ifelse(plot_x_ticks,T,F))

  # Assign (unique) colours and shapes for each grouping variable
  variable_values <- levels(metadata.df[[variable_to_plot]])

  # If variable colour column "variable_colour" in metadata, use colours from there
  if (variable_colours_available == T){
    colour_col_name <- paste0(variable_to_plot, "_colour")
    variable_colours <- setNames(as.character(unique(metadata.df[[colour_col_name]])),
                                 as.character(unique(metadata.df[[variable_to_plot]])))
  } else if (!is.null(my_colour_palette)) {
    if (typeof(my_colour_palette) == "list" & all(variable_values %in% names(my_colour_palette)) & length(names(my_colour_palette)) == length(variable_values)){
      variable_colours <- my_colour_palette
    } else if (typeof(my_colour_palette) == "character" & length(my_colour_palette) == length(variable_values)) {
      colour_palette_distinct <- my_colour_palette
      variable_colours <- setNames(rep(colour_palette_distinct,length(variable_values))[1:length(variable_values)], variable_values)
    } else{
      warning("Provided palette must be a list(variable_group_value = colour...) or character vector c(colour1, colour2...), with entries for each variable value.
              Using default palette.")
      colour_palette_distinct <- c("#8eec45","#0265e8","#f6a800","#bf6549","#486900","#c655a0","#00d1b6","#ff4431","#aeb85c","#7e7fc8")
      variable_colours <- setNames(rep(colour_palette_distinct,length(variable_values))[1:length(variable_values)], variable_values)
    }
  }
  else{ # Otherwise use default palette
    colour_palette_distinct <- c("#8eec45","#0265e8","#f6a800","#bf6549","#486900","#c655a0","#00d1b6","#ff4431","#aeb85c","#7e7fc8")
    variable_colours <- setNames(rep(colour_palette_distinct,length(variable_values))[1:length(variable_values)], variable_values)
  }

  # Whether to use shapes
  if (use_shapes == T){
    # If variable shape column "variable_shape" in metadata, use shapes from there
    if (variable_shapes_available == T){
      shape_col_name <- paste0(variable_to_plot, "_shape")
      variable_shapes <- setNames(unique(metadata.df[[shape_col_name]]),
                                  as.character(unique(metadata.df[[variable_to_plot]])))

    } else{ # Use default pre-defined shapes
      # variable_shapes <- setNames(c(25,24,23,22,21,8,6,5,4,3,2,1)[1:length(variable_values)],variable_values)
      if (use_fill_shapes){
        variable_shapes <- setNames(rep(c(25,24,23,22,21),
                                        length(variable_values))[1:length(variable_values)],variable_values)
      }else{
        variable_shapes <- setNames(rep(c(6,5,2,1,0),
                                        length(variable_values))[1:length(variable_values)],variable_values)
      }
    }
  } else{
    if (use_fill_shapes){
      variable_shapes <- setNames(rep(c(21),length(variable_values))[1:length(variable_values)],variable_values)
    } else{
      variable_shapes <- setNames(rep(c(1),length(variable_values))[1:length(variable_values)],variable_values)
    }
  }

  # variable_colours <- colours.l[[variable_to_plot]] # Assumes colours.l a global variable
  # variable_shapes <- pchs.l[[variable_to_plot]]  # Assumes pchs.l a global variable, also assumes shapes are only 25,24,23,22,21 (I think)
  # variable_shapes <- setNames(rep(c(25,24,23,22,21),length(variable_values))[1:length(variable_values)],variable_values)

  # print(variable_values)
  # print(variable_colours)
  # print(variable_shapes)
  annotation_dataframe <- data.frame(variable_colours, variable_shapes, stringsAsFactors = F)
  annotation_dataframe$variable_outline_colours <- as.character(annotation_dataframe$variable_colours)
  if (point_line_thickness != 0){
    darken <- function(color, factor=1.4){
      col <- col2rgb(color)
      col <- col/factor
      col <- rgb(t(col), maxColorValue=255)
      col
    }

    lighten <- function(color, factor=1.4){
      col <- col2rgb(color)
      col <- col*factor
      col <- rgb(t(col), maxColorValue=255)
      col
    }
    if (point_line_is_darker_fill == T){
      annotation_dataframe[annotation_dataframe$variable_shapes > 15,"variable_outline_colours"] <-
        as.character(lapply(annotation_dataframe$variable_outline_colours, darken))
    } else{
      annotation_dataframe[annotation_dataframe$variable_shapes > 15,"variable_outline_colours"] <- "black"
    }
  }

  # Filter annotation dataframe to levels of interest
  if (!is.null(my_levels)){
    annotation_dataframe <- annotation_dataframe[my_levels,]
  }

  pca_site_scores <- pca_site_scores[rownames(metadata.df),]

  # Get the colours for all samples
  all_sample_colours <- as.character(
    lapply(
      as.character(metadata.df[rownames(pca_site_scores),variable_to_plot]),
      function(x) as.character(annotation_dataframe[x,"variable_colours"])
    )
  )

  # Get the shapes for all samples
  all_sample_shapes <- as.numeric(
    lapply(
      as.character(metadata.df[rownames(pca_site_scores),variable_to_plot]),
      function(x) annotation_dataframe[x,"variable_shapes"][[1]]
    )
  )

  # Set the outline colours for all samples based on the sample colours and refering to the annotation dataframe created above
  all_sample_outline_colours <- as.character(unlist(lapply(all_sample_colours,
                                                           function(x) annotation_dataframe[annotation_dataframe$variable_colours == x, "variable_outline_colours"])))

  points(pca_site_scores,
         cex = point_size,
         lwd = point_line_thickness,
         pch = all_sample_shapes,
         col = scales::alpha(all_sample_outline_colours,point_alpha),
         # col = alpha("black",point_alpha),
         bg = scales::alpha(all_sample_colours, point_alpha)
  )

  # Plot arrows for species / variables
  plot_arrows_func <- function(){

    left_pc1.v <- rownames(pca_specie_scores[order(pca_specie_scores[,1]),][1:num_top_species,])
    right_pc1.v <- rownames(pca_specie_scores[order(pca_specie_scores[,1]),][(length(pca_specie_scores[,1]) - num_top_species):length(pca_specie_scores[,1]),])

    left_pc2.v <- rownames(pca_specie_scores[order(pca_specie_scores[,2]),][1:num_top_species,])
    right_pc2.v <- rownames(pca_specie_scores[order(pca_specie_scores[,2]),][(length(pca_specie_scores[,2]) - num_top_species):length(pca_specie_scores[,2]),])

    top_vars.v <- unique(c(left_pc1.v, right_pc1.v, left_pc2.v, right_pc2.v))
    arrows(0,0,
           arrow_scalar * pca_specie_scores[top_vars.v,1],
           arrow_scalar * pca_specie_scores[top_vars.v,2],
           length =0.05,
           col = alpha(arrow_colour, arrow_alpha),
           lwd = arrow_thickness,
           lty = 1)

    if (label_arrows){
      if (!is.null(specie_labeller_function)){
        for (tv in top_vars.v){
          text(x = pca_specie_scores[tv,1]* arrow_scalar,
               y = pca_specie_scores[tv,2]* arrow_scalar,
               labels = specie_labeller_function(tv),
               cex = arrow_label_size,
               # Values of 1, 2, 3 and 4, respectively indicate positions below,
               # to the left of, above and to the right of the specified (x,y) coordinates.
               pos = sample(c(1,2,3,4),1),
               # pos = 2,
               offset = arrow_label_offset,
               col = alpha(arrow_label_colour,alpha = arrow_label_alpha),
               font = arrow_label_font_type)
        }
      } else{
        for (tv in top_vars.v){
          text(x = pca_specie_scores[tv,1] * arrow_scalar,
               y = pca_specie_scores[tv,2] * arrow_scalar,
               labels = tv,
               cex = arrow_label_size,
               # Values of 1, 2, 3 and 4, respectively indicate positions below,
               # to the left of, above and to the right of the specified (x,y) coordinates.
               pos = sample(c(1,2,3,4),1),
               # pos = 2,
               offset = arrow_label_offset,
               col = alpha(arrow_label_colour,alpha = arrow_label_alpha),
               font = arrow_label_font_type)
        }
      }
    }
  }

  if (plot_arrows == T){
    plot_arrows_func()
  }

  # Plot ellipses that are filled
  plot_ellipses_func <- function () {
    for (member in variable_values) {
      if (nrow(metadata.df[metadata.df[[variable_to_plot]] == member,,drop = F]) > 2){ # if too few samples, skip plotting ellipse
        ordiellipse(pca_site_scores,
                    groups = metadata.df[[variable_to_plot]],
                    kind = "ehull",
                    lwd = ellipse_border_width,
                    # border = variable_colours[member][[1]],
                    border = alpha(variable_colours[member][[1]],ellipse_alpha),
                    # col = variable_colours[member][[1]],
                    col = alpha(variable_colours[member][[1]],ellipse_alpha),
                    show.groups = member,
                    alpha = .05,
                    draw = "polygon",
                    label = F,
                    cex = .5)
      }
    }
  }

  # Plot hulls that are filled
  plot_hulls_func <- function () {
    for (member in variable_values){
      if (nrow(metadata.df[metadata.df[[variable_to_plot]] == member,,drop = F]) > 2){ # if too few samples, skip plotting ellipse}
        ordihull(pca_site_scores,
                 groups = metadata.df[[variable_to_plot]],
                 lwd = ellipse_border_width,
                 # border = variable_colours[member][[1]],
                 border = alpha(variable_colours[member][[1]],hull_alpha),
                 # col = variable_colours[member][[1]],
                 col = alpha(variable_colours[member][[1]],hull_alpha),
                 show.groups = member,
                 alpha = .05,
                 draw = "polygon",
                 label = F,
                 cex = .5)
      }
    }
  }
  if (hasArg(plot_hulls)){
    if (plot_hulls == T){
      plot_hulls_func()
    }
  }

  #Plot spiders
  plot_spiders_func <- function (label_spider = F) {
    for (member in variable_values){
      if (nrow(metadata.df[metadata.df[[variable_to_plot]] == member,,drop = F]) > 2){ # if too few samples, skip plotting ellipse
        ordispider(pca_site_scores,
                   groups = metadata.df[[variable_to_plot]],
                   # col = variable_colours[member][[1]],
                   col = alpha(variable_colours[member][[1]],spider_alpha),
                   show.groups = member,
                   #alpha = .05,
                   label = label_spider,
                   cex = spider_label_size)
      }
    }
  }
  if (hasArg(plot_spiders)){
    if (plot_spiders == T){
      plot_spiders_func(label_spider = label_spider)
    }
  }

  plot_ellipses_labels_func <- function(label_ellipse = F){
    # Repeat to have labels clearly on top of all ellipses
    for (member in variable_values){
      if (nrow(metadata.df[metadata.df[[variable_to_plot]] == member,,drop = F]) > 2){ # if too few samples, skip plotting ellipse
        ordiellipse(pca_site_scores,
                    groups = metadata.df[[variable_to_plot]],
                    kind = "ehull",
                    # border = variable_colours[member][[1]],
                    border = NA,
                    # col = variable_colours[member][[1]],
                    col = NA,
                    show.groups = member,
                    alpha = 0,
                    draw = "polygon",
                    label = label_ellipse,
                    cex = ellipse_label_size)
      }
    }
  }

  if (hasArg(plot_ellipses) | hasArg(label_ellipse)){
    if (plot_ellipses == T){
      plot_ellipses_func()
      plot_ellipses_labels_func(label_ellipse = label_ellipse)
    } else if (label_ellipse == T){
      plot_ellipses_labels_func(label_ellipse = label_ellipse)
    }
  }

  if (label_sites == T){
    text(x = pca_site_scores[,1],
         y = pca_site_scores[,2],
         labels = rownames(pca_site_scores),
         cex = .5,
         pos = 2)
  }
  if (label_species == T){
    text(x = pca_specie_scores[,1],
         y = pca_specie_scores[,2],
         labels = rownames(pca_specie_scores),
         cex = .5,
         pos = 2)
  }
  if (is.null(legend_x)){
    legend_x <- x_min + legend_x_offset
  }
  if (is.null(legend_y)){
    legend_y <- y_max + legend_y_offset
  }
  if (is.null(legend_title)){
    legend_title <- variable_to_plot
  }

  if (!is.null(plot_title)){
    title(main = plot_title, cex.main = title_cex)
  }

  legend_bty = "n"
  if (!is.null(legend_fill_colour)){
    legend_bty <- "o"
    legend_fill <- legend_fill_colour
    legend_colour <- legend_fill_colour
  }

  if (include_legend){
    legend(
      # title = bold(variable_to_plot),
      title = as.expression(bquote(bold(.(legend_title)))),
      # title.adj = 0.5,
      title.col="black",
      # x = x_min-4,
      # y = y_max-6,
      x = legend_x,
      y = legend_y,
      # legend= variable_values,
      # pch= unique(all_sample_shapes),
      # col= legend_point_outline_colours,
      # pt.bg = unique(all_sample_colours),
      legend= rownames(annotation_dataframe),
      pch= annotation_dataframe$variable_shapes,
      col= as.character(annotation_dataframe$variable_outline_colours),
      pt.bg = as.character(annotation_dataframe$variable_colours),
      #bg = "white",
      bty = legend_bty,
      bg = legend_fill,
      box.col = legend_colour,
      ncol = legend_columns,
      cex = legend_cex,
      # pt.cex = 0.6,
      pt.lwd = point_line_thickness,
      y.intersp =1,
      x.intersp = legend_key_text_distance, # Distance between legend keys and text
      xjust = 0,
      # yjust = 1,
      title.adj = 0.5,
      text.width = legend_column_spacing # Distance between legend columns
    )
  }
  if (!is.null(filename)){
    dev.off()
  }
}


